#version 450

layout (binding = 0, rgba32f) uniform image2D destTex;
layout (local_size_x = 16, local_size_y = 16) in;

uniform vec4 imageSize;

#define PI 3.14159265359
#define FOCAL_LENGTH 1.0

const vec2 MSAA_pixel_samples[4] = {
       vec2(0.125, 0.625),
       vec2(0.375, 0.125),
       vec2(0.875, 0.375),
       vec2(0.625, 0.875)
    };

const float infinity = 1.0/0.0;         // OpenGL > 4.1
const float aspect_raito = imageSize.x / imageSize.y;
const float viewport_height = 2.0;
const float viewport_width = aspect_raito * viewport_height;
    
const vec3 horizontal = vec3(viewport_width, 0, 0);
const vec3 vertical = vec3(0, viewport_height, 0);

const vec3 ray_origin = vec3(0.0, 0.0, 0.0);
const vec4 sphere = vec4(0.0, 0.0, -1.0, 0.5);

struct Ray
{
    vec3 orig;
    vec3 dir;
} ;//ray;

struct hit_info {
    vec3 p;
    vec3 normal;
    float t;
    bool front_face;
};

// Utility Functions
float degrees_to_radians(float degrees);

// Traicing functions
vec4 ray_color(Ray r);
vec3 ray_point(Ray r, float t);
Ray get_ray(vec2 uv);
bool hit_sphere(vec4 s, Ray r, out hit_info hit, float t_min = 0.0, float t_max = 10000.0);

void main()
{
    // Image space calculation
    vec2 screenCoords = gl_GlobalInvocationID.xy;
    screenCoords.y = imageSize.y - gl_GlobalInvocationID.y;
    vec2 uv = vec2(screenCoords) / imageSize.xy;
    
    // Basic variables

    vec4 color = vec4(0.0);
    Ray ray;
    for(int i = 0; i < 4; ++i)
    { 
        vec2 ray_uv = uv + MSAA_pixel_samples[i] / imageSize.xy; 
        ray = get_ray(ray_uv);
        color += ray_color(ray);
    }
    color /= 4.0;
    
    ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
    imageStore(destTex, storePos, color);
    //imageStore(destTex, storePos, vec4(c, 0.0, 1.0));
}

vec4 ray_color(Ray r)
{
    hit_info hit;
    if(hit_sphere(sphere, r,  hit)) return vec4(0.5 * hit.normal + 0.5, 1.0);

    vec3 runitdir = normalize(r.dir);
    float t = 0.5*(runitdir.y + 1.0); 
    
    vec4 color = mix( vec4(1.0, 1.0, 1.0, 1.0), vec4(0.5, 0.7, 1.0, 1.0), t);
    return color;
}


bool hit_sphere(vec4 s, Ray r, out hit_info hit, float t_min = 0.0, float t_max = 10000.0)
{
    vec3 oc = r.orig - s.xyz;
    float a = dot(r.dir, r.dir);
    float half_b = dot(r.dir, oc);
    float c = dot(oc, oc) - s.w * s.w;
    float half_discr = half_b*half_b - a*c;
    
    if (half_discr < 0) return false;
    
    float t = (-half_b - sqrt(half_discr)) / a;
    if(t < t_min || t > t_max)   return false;

    hit.t = t;
    hit.p = r.orig + normalize(r.dir) * hit.t;
    vec3 normal = normalize(hit.p - s.xyz);
    hit.front_face = dot(normalize(r.dir), normal) <= 0;

    hit.normal = hit.front_face ? normal : -normal;

    return true;
}

vec3 ray_point(Ray r, float t)
{
    return r.orig + r.dir * t; 
}


// Utility Functions
float degrees_to_radians(float degrees)
{
    return degrees * PI / 180.0;
}

Ray get_ray(vec2 uv)
{
    vec3 lower_left_corner = ray_origin - horizontal / 2.0 - vertical / 2.0 - vec3(0.0, 0.0, FOCAL_LENGTH);
    return Ray(ray_origin, lower_left_corner + horizontal * uv.x + vertical * uv.y - ray_origin);
}
